// This file is released under the BSD 2-Clause License
//
// Copyright (c) 2018, zenith-parsec
// All rights reserved.
//
// See LICENSE for actual text of license.

// So...
// If you want to know how this program actually works, search for this:
// ################ 
// The magic code is under that.
//
// But you are going to have to read the rest too, because a magician still needs
// a stage to perform on, and a tailor to make his fancy suit, and someone
// to make sure the trapdoor is oiled regularly.
//
// But the TL;DR is:
//
// This code works by magic.

#include <iostream>

// https://opencv.org/ -- developed with OpenCV v3.0, last tested with v3.4
#include "opencv2/opencv.hpp"

// https://dlib.net/ -- developed with Dlib v18.10, last tested with 18.18; will probably work with 19.10 if you use VS2015 (was testing using VS2013)

#include <dlib/opencv/cv_image.h>
#include <dlib/opencv/to_open_cv.h>
#include <dlib/image_processing/frontal_face_detector.h>
#include <dlib/image_processing/render_face_detections.h>
#include <dlib/image_processing.h>
#include <dlib/gui_widgets.h>
#include <dlib/image_io.h>


// there is a good reason for having this data in here twice... really. Not sure 
// what it was anymore.

// The tris[][][] array is the connection data for the face point data: the index of the points which make up each 
// actual triangle. It's generated by the makeTris() function from the .dat input file... and it's hard coded in 
// here for... some good reason, I think.

// Anyway, I originally wrote this in 2014, and now it is 2018.... I remember it had something to do with using a
// Delaunay triangulation of the average of the detection points. It looks as though I convert the points into the index
// using a very long 'sed' command. (If you use bash, you probably have sed. If you don't know what that means,
// you probably don't. But don't worry... I've already done it, but left the code in so I could make it work with
// other data later. Like tris[1], which I think was my attempt at a higher count 

const unsigned int trinum[2] = { 112, 332 };

const unsigned int tris[2][512][3] =
{
	{
		{ 36, 0, 17 }, { 0, 36, 1 }, { 8, 57, 9 }, { 57, 8, 58 }, { 3, 48, 4 }, { 48, 3, 2 }, { 2, 1, 36 }, { 50, 31, 32 },
		{ 31, 50, 49 }, { 59, 7, 6 }, { 7, 59, 58 }, { 56, 9, 57 }, { 9, 56, 10 }, { 5, 4, 48 }, { 2, 31, 48 }, { 31, 2, 36 },
		{ 6, 5, 48 }, { 14, 46, 15 }, { 46, 14, 35 }, { 8, 7, 58 }, { 47, 35, 30 }, { 35, 47, 46 }, { 11, 10, 55 }, { 47, 30, 29 },
		{ 12, 11, 54 }, { 18, 37, 36 }, { 37, 18, 19 }, { 13, 12, 54 }, { 15, 13, 14 }, { 14, 13, 35 }, { 19, 38, 37 }, { 38, 19, 20 },
		{ 18, 36, 17 }, { 16, 15, 45 }, { 21, 22, 27 }, { 22, 21, 23 }, { 40, 29, 31 }, { 29, 40, 39 }, { 17, 0, 18 }, { 27, 22, 42 },
		{ 20, 23, 21 }, { 23, 20, 24 }, { 20, 21, 39 }, { 27, 42, 28 }, { 29, 42, 47 }, { 42, 29, 28 }, { 46, 43, 44 }, { 43, 46, 47 },
		{ 43, 22, 23 }, { 22, 43, 42 }, { 44, 24, 25 }, { 24, 44, 23 }, { 43, 23, 44 }, { 26, 16, 45 }, { 25, 26, 44 }, { 21, 27, 39 },
		{ 43, 47, 42 }, { 36, 41, 31 }, { 41, 36, 37 }, { 27, 28, 39 }, { 53, 35, 54 }, { 35, 53, 52 }, { 31, 29, 30 }, { 28, 29, 39 },
		{ 52, 34, 35 }, { 34, 52, 33 }, { 31, 49, 48 }, { 58, 66, 57 }, { 66, 58, 67 }, { 63, 51, 52 }, { 51, 63, 62 }, { 31, 30, 32 },
		{ 33, 51, 50 }, { 51, 33, 52 }, { 32, 30, 33 }, { 32, 33, 50 }, { 33, 30, 34 }, { 35, 13, 54 }, { 34, 30, 35 }, { 38, 40, 37 },
		{ 40, 38, 39 }, { 38, 20, 39 }, { 37, 40, 41 }, { 40, 31, 41 }, { 26, 45, 44 }, { 15, 46, 45 }, { 44, 45, 46 }, { 6, 48, 59 },
		{ 48, 49, 60 }, { 62, 66, 61 }, { 66, 62, 65 }, { 49, 50, 61 }, { 10, 56, 55 }, { 50, 51, 61 }, { 55, 54, 11 }, { 54, 55, 64 },
		{ 63, 52, 53 }, { 53, 54, 64 }, { 64, 63, 53 }, { 63, 64, 65 }, { 63, 65, 62 }, { 61, 67, 49 }, { 67, 61, 66 }, { 55, 56, 65 },
		{ 56, 57, 66 }, { 49, 59, 60 }, { 59, 49, 67 }, { 59, 48, 60 }, { 58, 59, 67 }, { 61, 51, 62 }, { 66, 65, 56 }, { 65, 64, 55 }
	},
	{
		{ 125, 164, 163 }, { 43, 42, 59 }, { 17, 16, 177 }, { 108, 107, 171 }, { 175, 14, 12 }, { 104, 43, 103 }, { 72, 76, 71 }, { 128, 139, 161 },
		{ 164, 125, 124 }, { 105, 86, 85 }, { 29, 31, 28 }, { 167, 4, 166 }, { 14, 175, 176 }, { 78, 25, 80 }, { 76, 72, 75 }, { 150, 148, 161 },
		{ 37, 147, 38 }, { 86, 105, 104 }, { 31, 29, 30 }, { 112, 168, 113 }, { 185, 12, 184 }, { 62, 63, 83 }, { 164, 124, 123 }, { 148, 150, 139 },
		{ 147, 37, 36 }, { 43, 44, 103 }, { 58, 132, 56 }, { 166, 3, 165 }, { 12, 185, 11 }, { 63, 62, 85 }, { 30, 29, 74 }, { 192, 160, 162 },
		{ 1, 0, 53 }, { 44, 43, 58 }, { 132, 58, 131 }, { 114, 167, 115 }, { 8, 9, 188 }, { 69, 78, 67 }, { 74, 29, 75 }, { 160, 192, 191 },
		{ 112, 169, 168 }, { 49, 53, 50 }, { 130, 84, 18 }, { 115, 167, 166 }, { 79, 176, 175 }, { 78, 69, 77 }, { 31, 30, 129 }, { 146, 33, 145 },
		{ 169, 112, 111 }, { 44, 45, 103 }, { 84, 130, 40 }, { 115, 166, 116 }, { 176, 79, 68 }, { 64, 63, 86 }, { 160, 142, 143 }, { 126, 143, 144 },
		{ 1, 133, 106 }, { 45, 44, 58 }, { 27, 32, 33 }, { 116, 166, 118 }, { 134, 136, 135 }, { 64, 86, 87 }, { 142, 160, 159 }, { 141, 142, 159 },
		{ 133, 1, 53 }, { 86, 104, 87 }, { 32, 27, 28 }, { 118, 166, 119 }, { 136, 134, 133 }, { 65, 64, 87 }, { 21, 36, 37 }, { 178, 179, 17 },
		{ 113, 167, 114 }, { 170, 110, 109 }, { 18, 19, 39 }, { 117, 106, 134 }, { 9, 10, 187 }, { 26, 78, 77 }, { 32, 31, 145 }, { 179, 178, 148 },
		{ 167, 113, 168 }, { 110, 170, 169 }, { 19, 18, 83 }, { 149, 117, 134 }, { 57, 177, 68 }, { 77, 71, 76 }, { 193, 5, 192 }, { 148, 2, 183 },
		{ 101, 173, 107 }, { 45, 47, 102 }, { 62, 18, 84 }, { 165, 119, 166 }, { 177, 57, 46 }, { 76, 28, 77 }, { 33, 32, 145 }, { 148, 149, 179 },
		{ 173, 101, 174 }, { 52, 50, 53 }, { 18, 62, 83 }, { 121, 165, 122 }, { 154, 185, 184 }, { 74, 75, 73 }, { 158, 190, 189 }, { 151, 134, 152 },
		{ 141, 158, 140 }, { 50, 52, 51 }, { 23, 34, 22 }, { 122, 165, 164 }, { 185, 154, 155 }, { 75, 29, 76 }, { 190, 158, 159 }, { 179, 180, 17 },
		{ 158, 141, 159 }, { 88, 103, 89 }, { 34, 23, 25 }, { 164, 123, 122 }, { 10, 11, 186 }, { 30, 74, 129 }, { 20, 37, 38 }, { 180, 179, 149 },
		{ 3, 4, 193 }, { 103, 88, 87 }, { 19, 20, 38 }, { 121, 122, 123 }, { 11, 10, 173 }, { 72, 73, 75 }, { 34, 33, 146 }, { 161, 139, 150 },
		{ 4, 3, 166 }, { 47, 48, 100 }, { 20, 19, 82 }, { 163, 143, 126 }, { 11, 173, 174 }, { 165, 120, 119 }, { 145, 142, 141 }, { 161, 148, 172 },
		{ 175, 90, 79 }, { 89, 103, 102 }, { 26, 33, 25 }, { 143, 163, 162 }, { 135, 154, 153 }, { 120, 165, 121 }, { 142, 145, 144 }, { 149, 151, 180 },
		{ 90, 175, 174 }, { 48, 49, 100 }, { 33, 26, 27 }, { 129, 144, 31 }, { 154, 135, 136 }, { 74, 73, 129 }, { 36, 34, 146 }, { 152, 181, 151 },
		{ 157, 140, 158 }, { 53, 0, 52 }, { 20, 21, 37 }, { 144, 129, 127 }, { 12, 11, 174 }, { 145, 31, 144 }, { 142, 144, 143 }, { 153, 182, 152 },
		{ 140, 157, 138 }, { 102, 47, 100 }, { 21, 20, 82 }, { 126, 125, 163 }, { 176, 15, 14 }, { 110, 169, 111 }, { 137, 131, 138 }, { 154, 184, 153 },
		{ 130, 138, 131 }, { 49, 50, 99 }, { 19, 83, 82 }, { 127, 126, 144 }, { 15, 176, 16 }, { 63, 85, 86 }, { 147, 140, 138 }, { 155, 186, 185 },
		{ 138, 130, 147 }, { 100, 49, 99 }, { 32, 28, 31 }, { 139, 149, 148 }, { 13, 2, 178 }, { 87, 104, 103 }, { 140, 147, 146 }, { 186, 155, 156 },
		{ 4, 5, 193 }, { 92, 100, 99 }, { 21, 22, 36 }, { 130, 18, 147 }, { 12, 174, 175 }, { 85, 84, 105 }, { 18, 39, 147 }, { 156, 138, 157 },
		{ 5, 4, 167 }, { 100, 92, 91 }, { 22, 21, 81 }, { 16, 180, 181 }, { 152, 135, 153 }, { 103, 45, 102 }, { 19, 38, 39 }, { 187, 10, 186 },
		{ 170, 108, 171 }, { 50, 51, 98 }, { 22, 81, 80 }, { 106, 133, 134 }, { 135, 152, 134 }, { 102, 91, 89 }, { 39, 38, 147 }, { 188, 9, 187 },
		{ 108, 170, 109 }, { 52, 0, 96 }, { 23, 22, 80 }, { 149, 134, 151 }, { 12, 14, 184 }, { 91, 102, 100 }, { 84, 40, 105 }, { 189, 8, 188 },
		{ 136, 131, 137 }, { 52, 97, 51 }, { 65, 81, 82 }, { 181, 180, 151 }, { 178, 46, 35 }, { 99, 93, 92 }, { 49, 54, 53 }, { 190, 7, 189 },
		{ 131, 136, 132 }, { 97, 52, 96 }, { 81, 65, 66 }, { 182, 181, 152 }, { 46, 178, 177 }, { 93, 99, 98 }, { 54, 49, 48 }, { 7, 190, 191 },
		{ 5, 6, 192 }, { 58, 43, 59 }, { 107, 173, 171 }, { 181, 182, 15 }, { 56, 133, 55 }, { 6, 168, 169 }, { 56, 45, 58 }, { 192, 6, 191 },
		{ 6, 5, 168 }, { 131, 58, 59 }, { 25, 23, 80 }, { 155, 136, 137 }, { 133, 56, 132 }, { 99, 50, 98 }, { 45, 56, 47 }, { 160, 143, 162 },
		{ 10, 171, 173 }, { 184, 182, 153 }, { 81, 66, 80 }, { 136, 155, 154 }, { 14, 15, 182 }, { 94, 98, 97 }, { 105, 40, 41 }, { 162, 193, 192 },
		{ 171, 10, 9 }, { 182, 184, 14 }, { 26, 25, 78 }, { 186, 11, 185 }, { 178, 24, 13 }, { 98, 94, 93 }, { 41, 40, 61 }, { 193, 162, 163 },
		{ 156, 137, 138 }, { 59, 42, 60 }, { 25, 33, 34 }, { 187, 156, 157 }, { 24, 178, 35 }, { 98, 51, 97 }, { 64, 83, 63 }, { 172, 148, 183 },
		{ 137, 156, 155 }, { 8, 169, 170 }, { 27, 26, 77 }, { 156, 187, 186 }, { 55, 47, 56 }, { 94, 97, 95 }, { 83, 64, 82 }, { 3, 193, 163 },
		{ 6, 7, 191 }, { 131, 59, 60 }, { 67, 80, 66 }, { 145, 141, 146 }, { 47, 55, 48 }, { 96, 95, 97 }, { 42, 105, 41 }, { 3, 163, 164 },
		{ 7, 6, 169 }, { 131, 60, 130 }, { 80, 67, 78 }, { 189, 157, 158 }, { 15, 16, 181 }, { 90, 101, 107 }, { 105, 42, 104 }, { 3, 164, 165 },
		{ 9, 170, 171 }, { 60, 41, 61 }, { 28, 27, 77 }, { 157, 189, 188 }, { 178, 2, 148 }, { 101, 90, 174 }, { 42, 41, 60 }, { 16, 176, 177 },
		{ 170, 9, 8 }, { 130, 60, 61 }, { 70, 77, 69 }, { 146, 141, 140 }, { 133, 54, 55 }, { 168, 5, 167 }, { 48, 55, 54 }, { 176, 68, 177 },
		{ 132, 136, 133 }, { 40, 130, 61 }, { 77, 70, 71 }, { 191, 159, 160 }, { 54, 133, 53 }, { 128, 149, 139 }, { 82, 64, 65 }, { 17, 177, 178 },
		{ 7, 8, 189 }, { 21, 82, 81 }, { 22, 34, 36 }, { 159, 191, 190 }, { 16, 17, 180 }, { 149, 128, 117 }, { 42, 43, 104 }, { 187, 157, 188 },
		{ 8, 7, 169 }, { 62, 84, 85 }, { 29, 28, 76 }, { 147, 36, 146 },
	}
};


using namespace cv;
using namespace dlib;
using namespace std;
//using namespace ps3eye;

inline std::vector<image_window::overlay_line> my_render_face_detections(
	const std::vector<full_object_detection>& dets,
	const rgb_pixel color = rgb_pixel(0, 255, 0)
	)
{
	std::vector<image_window::overlay_line> lines;
	for (unsigned long i = 0; i < dets.size(); ++i)
	{

		const full_object_detection& d = dets[i];
		unsigned int n = d.num_parts();
		for (unsigned long i = 1; i <= n; ++i)
			lines.push_back(image_window::overlay_line(d.part(i) * 2, d.part(i - 1) * 2, color));
		lines.push_back(image_window::overlay_line(d.part(0) * 2, d.part(n - 1) * 2, color));


	}
	return lines;
}


// ----------------------------------------------------------------------------------------

#define ASIZ(x) (sizeof(x) / sizeof(x[0]))

void makeTris(Rect &border, std::vector<Point2f>&p)
{
	Subdiv2D sd(border);
	sd.insert(p);

	std::vector<Vec6f> t;
	sd.getTriangleList(t);

	// this generates a sed script that converts the points

	std::cout << endl << endl << "sed ";
	for (unsigned int i = 0; i < p.size(); i++)
	{
		std::cout << " -e 's/\\" << p[i] << "/" << i << "/'";
	}
	std::cout << endl;

	for (unsigned int i = 0; i < t.size(); i++)
	{
		Vec6f &v(t[i]);
		Point2f a = Point2f(v[0], v[1]);
		Point2f b = Point2f(v[2], v[3]);
		Point2f c = Point2f(v[4], v[5]);
		if (a.x < border.x) continue;
		if (a.y < border.y) continue;
		if (b.x < border.x) continue;
		if (b.y < border.y) continue;
		if (c.x < border.x) continue;
		if (c.y < border.y) continue;

		if (a.x > border.x + border.width) continue;
		if (a.y > border.y + border.height) continue;
		if (b.x > border.x + border.width) continue;
		if (b.y > border.y + border.height) continue;
		if (c.x > border.x + border.width) continue;
		if (c.y > border.y + border.height) continue;

		std::cout << "\t{ " << a;
		cout << ",\t" << b;
		std::cout << ",\t" << c << " }," << endl;
	}
	std::cout << "};" << endl;
	while (1) {}

}

// This one does the magic... it warps the texture from face1 over the detected face in the image, one triangle at a time.
// it sounds easy, right? all you have to do is identify the same points on each face, and then for each triangle in tris[][][],
// copy the texture from the 1st one into the 2nd one.

void warp(Mat m1, full_object_detection& fod1, Mat m2, full_object_detection& fod2, Point& addToFOD2, bool &scaled)
{
	int which = -1;


	// check we have a fod1 if the number of parts is not a known value, then
	// we are going to fail.
	if ((fod1.num_parts() != 68) && (fod1.num_parts() != 194))
	{
		std::cout << "fod1 has " << fod1.num_parts() << " parts" << endl;
		return;
	}

	// and fod2 also has to be valud.
	if ((fod2.num_parts() != 68) && (fod2.num_parts() != 194))
	{
		std::cout << "fod2 has " << fod2.num_parts() << " parts" << endl;
		return;
	}

	// and they have to be the same.
	if (fod1.num_parts() != fod2.num_parts())
	{
		std::cout << "fod1 has " << fod1.num_parts() << " parts" << endl;
		std::cout << "fod2 has " << fod2.num_parts() << " parts" << endl;
		return;
	}

	// 68 parts means it is the dlib detector dat file... 194 means it is my 
	// totally broken one that tried to make from a whole lot of images. And
	// it totally sucks. I'm not sharing it. It's mostly because the triangles 
	// have overlaps, but also because the .dat file is about 200 MB. 

	if (fod1.num_parts() == 68) which = 0; else which = 1;

	long sc_x = 1;
	long sc_y = 1;

	// This code is here for historical reasons, so you can see what it
	// was like back in the year 2014... but other than that, I don't
	// remember why it was a good idea, and all I'm doing now, in 2018,
	// is commenting stuff, and cleaning up extremely unneeded stuff.
	if (0 && scaled)
	{
		sc_x = 2;
		sc_y = 2;
	}

	Point2f srcTri[3]; // source triangle, made of 2d floating-point points.
	Point2f dstTri[3]; // destination triangle, made of 2d floating-point points.

	Point dstTriPt[3]; // destination triangle , made of 2d integer points.

	std::vector<Point2f>pt1; // mutable copy of src points
	std::vector<Point2f>pt2; // mutable copy of dst points

	int min1x = m1.cols;
	int min1y = m1.rows;
	int max1x = 0;
	int max1y = 0;

	int min2x = m2.cols;
	int min2y = m2.rows;
	int max2x = 0;
	int max2y = 0;


	// so duplicate the each set of points, but also find the entire ROI...
	// i have a feeling the would have been an easier way to do this.
	// also use those sc_[xy] values from above... and history making
	// code... 
	// When I say "There was probably a good reason," what I actually
	// mean is "I probably thought it was a good idea at some point."

	for (unsigned long i = 0; i < fod1.num_parts(); i++)
	{
		const point &f1 = fod1.part(i);
		const point &f2 = fod2.part(i);

		int x1 = f1.x();
		int y1 = f1.y();

		if (x1 > max1x)max1x = x1;
		if (y1 > max1y)max1y = y1;

		if (x1 < min1x)min1x = x1;
		if (y1 < min1y)min1y = y1;

		int x2 = (f2.x()) * sc_x;// + addToFOD2.x;
		int y2 = (f2.y()) * sc_y;// + addToFOD2.y;

		if (x2 > max2x)max2x = x2;
		if (y2 > max2y)max2y = y2;

		if (x2 < min2x)min2x = x2;
		if (y2 < min2y)min2y = y2;

		pt1.push_back(Point2f(x1, y1));
		pt2.push_back(Point2f(x2, y2));
	}

	// And here is the code which made the tris[][][] struct filter thing... probably in comination with some other 
	// scripting voodoo..

	//	Rect quick(min1x, min1y, max1x , max1y );
	//	makeTris(quick, pt1);

	if (max1x > m1.cols) max1x = m1.cols;
	if (max1y > m1.rows) max1y = m1.rows;
	if (min1x < 0) min1x = 0;
	if (min1y < 0) min1y = 0;

	if (max2x > m2.cols) max2x = m2.cols;
	if (max2y > m2.rows) max2y = m2.rows;
	if (min2x < 0) min2x = 0;
	if (min2y < 0) min2y = 0;

	Rect border1(min1x, min1y, max1x - min1x, max1y - min1y);
	//cout << "border1 = (" << border1.x << "," << border1.y << ")-(" << border1.x + border1.width  << "," << border1.y + border1.height << ") [ " << border1.width << "x" << border1.height << "]"<< endl;
	//cout << " 0 <= " << border1.x << " && 0 <= " << border1.width  << " && " << border1.x + border1.width  << " <= " << m1.cols << " && " 
	//	 << " 0 <= " << border1.y << " && 0 <= " << border1.height << " && " << border1.y + border1.height << " <= " << m1.rows << endl;



	Rect border2(min2x, min2y, max2x - min2x, max2y - min2y);
	//cout << "border2 = (" << border2.x << "\t" << border2.y << "\t)-(" << border2.x + border2.width << "\t" << border2.y + border2.height << ")\t[ " << border2.width << "x" << border2.height << "]" << endl;
	//cout << " 0 <= " << border2.x << " && 0 <= " << border2.width  << " && " << border2.x + border2.width  << " <= " << m2.cols << " && " 
	//	 << " 0 <= " << border2.y << " && 0 <= " << border2.height << " && " << border2.y + border2.height << " <= " << m2.rows << endl;

	Mat faceRegion1(m1, border1);
	Mat faceRegion2(m2, border2);
	Mat warp_mat;

	Point2f minPt1(min1x, min1y);
	Point2f minPt2(min2x, min2y);
	// more offsets...
	// All I know is scanning a small area is much faster in detection phase.
	// I have no idea if this helps at all.
	for (unsigned long i = 0; i < fod1.num_parts(); i++)
	{
		pt1[i] -= minPt1;
		pt2[i] -= minPt2;
	}

	Mat tmpMat(faceRegion2.size(), faceRegion2.type(), Scalar(0, 0, 0));
	Mat mask(faceRegion2.size(), CV_8UC1);


	mask = Scalar(0);

	for (unsigned long i = 0; i < trinum[which]; i++)
	{
		float dstR = 0;
		float dstB = 0;
		float dstL = max2x;
		float dstT = max2y;
		for (unsigned int j = 0; j < 3; j++)
		{
			srcTri[j] = pt1[tris[which][i][j]];
			dstTri[j] = pt2[tris[which][i][j]];

			float x2 = dstTri[j].x;
			float y2 = dstTri[j].y;

			// why didn't I just use the Rect 'union' operator?
			// because I didn't think of that.

			if (dstR < x2) dstR = x2;
			if (dstL > x2) dstL = x2;

			if (dstB < y2) dstB = y2;
			if (dstT > y2) dstT = y2;
		}

		// why didn't I just write a 'clampToRange(float &x,float min, float max);' function?
		// Because I'm not very smart?
		// Because C++ is not my native language?
		// Because I wasn't aware anyone else would read it?
		// All of the above.

		if (dstL < 0) dstL = 0;
		if (dstT < 0) dstT = 0;
		if (dstR < 0) dstR = 0;
		if (dstB < 0) dstB = 0;

		if (dstL > faceRegion2.cols) dstL = faceRegion2.cols;
		if (dstT > faceRegion2.rows) dstT = faceRegion2.rows;
		if (dstR > faceRegion2.cols) dstR = faceRegion2.cols;
		if (dstB > faceRegion2.rows) dstB = faceRegion2.rows;

		// I'm a firm believer in the power of debugging with printf.
		// C++ makes that both easier and harder.
		// but it's better than debugging with actual crashes.
		//		std::cout << dstL << "\t" << dstT << "\t" << dstR << "\t" << dstB << endl;

		// ################
		// AND HERE IS THE MAGIC!!!!

		warp_mat = getAffineTransform(srcTri, dstTri);
		warpAffine(faceRegion1, tmpMat, warp_mat, tmpMat.size(), INTER_NEAREST);


		int dstW, dstH;
		dstW = (int)(dstR - dstL);
		dstH = (int)(dstB - dstT);

		Rect roi2(dstL, dstT, dstW, dstH);

		dstTriPt[0] = dstTri[0];
		dstTriPt[1] = dstTri[1];
		dstTriPt[2] = dstTri[2];

		//		std::cout << "[" << i << "] = {" << dstTriPt[0] << ","<< dstTriPt[1] << ","<< dstTriPt[2] << "}" << endl;
		//cout << " 0 <= " << roi2.x << " && 0 <= " << roi2.width  << " && " << roi2.x + roi2.width  << " <= " << faceRegion2.cols << " && " 
		//	 << " 0 <= " << roi2.y << " && 0 <= " << roi2.height << " && " << roi2.y + roi2.height << " <= " << faceRegion2.rows << endl;

		Mat maskroi(mask, roi2);
		Mat faceRegion2roi(faceRegion2, roi2);
		Mat tmpMatRoi(tmpMat, roi2);

		// draw triangle on mask. which is stored in dstTriPt, contains 
		// 3 elements, and should be drawn with '4-neighbor' lines.
		fillConvexPoly(mask, dstTriPt, 3, 255, 4);

		//		std::cout << "copyTo. " << endl;
		tmpMatRoi.copyTo(faceRegion2roi, maskroi);

		// so what just happened?
		// align the images, warping the src so the triangle to copy is the same shape as the destination
		// then make a mask the same shape as the dest triangle, and copy the warped src into it.
		// simple, right? almost... magic!
		maskroi = Scalar(0);
	}
}

int main(int argc, char** argv)
{
	// This example takes in a shape model file and then a list of images to
	// process.  We will take these filenames in as command line arguments.
	// Dlib comes with example images in the examples/faces folder so give
	// those as arguments to this program.

	if (argc != 2 && argc != 3)
	{
		cout << "need to give the .dat file name." << endl << "you can download it from:" << endl << "\thttp://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2" << endl;
		return -3;
	}


	cv::VideoCapture cap;

	if (argc == 3)
	{
		cap.open(argv[2]);
	}

	if (!cap.isOpened())
	{
		cap.open(0);
	}

	if (!cap.isOpened())
	{
		std::cout << "failed to open cam." << endl;
		return -1;
	}

	cap.set(CV_CAP_PROP_FRAME_WIDTH, 720);
	cap.set(CV_CAP_PROP_FRAME_HEIGHT, 480);
	//		cap.set(CV_CAP_PROP_EXPOSURE, 100); << grr

	// We need a face detector.  We will use this to get bounding boxes for
	// each face in an image.

	frontal_face_detector faceDetector = get_frontal_face_detector();

	// And we also need a shape_predictor.  This is the tool that will predict face
	// landmark positions given an image and face bounding box.  Here we are just
	// loading the model from the shape_predictor_68_face_landmarks.dat file you gave
	// as a command line argument.

	std::cout << "reading dat file..." << endl;
	shape_predictor sp;
	//		deserialize("shape_predictor_68_face_landmarks.dat") >> sp;
	deserialize(argv[1]) >> sp;
	std::cout << "completed." << endl;
	cv::Mat frame;

	cout << "loading face1...";
	cout.flush();

	Mat f1cvimg;
	f1cvimg = imread("face1.png", 1);
	if (f1cvimg.empty())
	{
		cout << "There must be a file named 'face1.png' in the current directory." << endl << "This file will be used as the initial 'face1'. image." << endl;
	}
	cout << "done. it has depth of " << f1cvimg.channels() << " channels." << endl;

	cv_image<rgb_pixel> face1(f1cvimg);

	cout << "detecting face1..." << endl;
	cout << endl;
	std::vector<dlib::rectangle> f1dets = faceDetector(face1, 0.);


	if (f1dets.size() < 1)
	{
		std::cout << "no face in replacement (face1) image?" << endl;

		return -5;
	}

	full_object_detection f1shape = sp(face1, f1dets[0]);
	std::cout << "number of parts: " << f1shape.num_parts() << endl;

	cap >> frame;

	if (frame.empty())
	{
		std::cout << "failed to get initial frame." << endl;
		return -2;
	}


	cv_image<bgr_pixel> tmpImg;
	image_window win(tmpImg);
	unsigned long screen_width, screen_height;
	win.get_display_size(screen_width, screen_height);


	win.set_pos(0, 0);
	win.set_size(screen_width, screen_height);

	uint64_t sh_sw_rat = (screen_height * 100) / screen_width;
	uint64_t cam_rat = (480 * 100) / 720;
	screen_width /= cam_rat;
	screen_width *= sh_sw_rat;

	screen_height /= 2;
	screen_width /= 2;
	cout << screen_width << "," << screen_height << endl;

	bool hadDet = false;
	full_object_detection shape;
	cv_image<unsigned char> smimg;
	cv::Mat smallFrame;
	bool scaled = false;


	Mat frameFilt;
	Rect prevDet0(0, 0, 720, 480);
	Size roiSZ(720, 480);
	Point roiPT(0, 0);
	while (1)
	{
		cap >> frame;
		resize(frame, frame, Size(720, 480));	// fixed values because.. um.. laziness. and was using a cheap webcam
		cvtColor(frame, frameFilt, CV_BGR2GRAY);
		cv_image<bgr_pixel> img(frame);
		cv_image<unsigned char> gray_img(frameFilt);

		// if a face is detected, the position of the face overwrites the previous guess.
		// or it should, any way
		// 
		if (hadDet)
		{
			// the whole point of doing this is so we don't  have to 
			// scan the entire screen everytime we want to do a 
			// detection. It's much faster to scan a small region,
			// so we copy the bounding box into a small image, and scan that.
			// add the roiPT, which is the offset.

			// For example
			//
			//     0,0  10,0  20,0  30,0  40,0
			//      +-----+-----+-----+-----+
			//      |                           1) det[0] is Rect(20, 10, 10, 10) (t,l,w,h)
			//      |                           2) shape is relative to det[0].
			// 0,10 +           +-------+       3) to get the actual offset, add top left corner.
			//      |           |.:. .:.|
			//      |           | :...: |
			// 0,20 +           +-------+
			//      |       det[0] --^
			//      |       bounding-box
			// 0,30 +
			//
			//


			// idea is: 
			//
			// you probably don't move far betwen frames. So next time, just look in the area immediately around here you were last time.
			//
			// imagine roiSZ = (160, 240) and roiPT = (120, 150) 
			// (this means opposite corner will be @ ( (160 + 120 - 1), (250 + 150 - 1) ) 
			// or (379, 399)
			//
			// roiPT.x = 160 - 10 = 150
			// rotPT.y = 240 - 15 = 225
			// roiSZ.width = 160 + 20 = 180;
			// roiSZ.height = 240 + 30 = 270;
			// 
			// now the opposite corner is @ ((150 + 180 -1), (225 + 270 -1))
			// or (389, 414)... the opposite side has gone up by the same amount
			// the labeled side has gone down. 

			roiPT.x = prevDet0.x - prevDet0.width / 8;
			roiPT.y = prevDet0.y - prevDet0.height / 8;
			if (roiPT.x < 0) roiPT.x = 0;
			if (roiPT.y < 0) roiPT.y = 0;
			// ^^ not sure why I did it this way, considering there is an 'intersection' operator for Rects...

			roiSZ.width = prevDet0.width + prevDet0.width / 4;
			roiSZ.height = prevDet0.height + prevDet0.height / 4;

			// if the ROI is too big to efficiently search
			if ((roiSZ.width > 400) || (roiSZ.height > 400))
			{

				roiPT.x /= 2;
				roiPT.y /= 2;
				roiSZ.width /= 2;
				roiSZ.height /= 2;

				resize(frameFilt, smallFrame, Size(360, 240), 0, 0, INTER_NEAREST); // INTER_NEAREST? really? ;/ seems to work though.
				cv::Rect cvrect(roiPT, roiSZ);										// make a CV rectangle
				cvrect &= Rect(Point(0, 0), smallFrame.size());						// clip it to the size of smallFrame
				smallFrame = smallFrame(cvrect);									// set smallFrame to be this current region of interest.

				smimg = cv_image<unsigned char>(smallFrame);						// make smimg into a dlib interface for smallframe.
				scaled = true;

			}
			else
			{
				cv::Rect cvrect(roiPT, roiSZ);					// make a CV rectangle 
				cvrect &= Rect(Point(0, 0), frame.size());		// clip it to the image size
				smallFrame = frameFilt(cvrect);					// set smallframe to be this current region of interest.
				smimg = cv_image<unsigned char >(smallFrame);	// make smimg into a dlib interface for smallframe.
				scaled = false;
			}
		}
		else
		{
			roiPT = Point(0, 0);
			roiSZ = Size(360, 240);
			resize(frameFilt, smallFrame, Size(360, 240), 0, 0, INTER_NEAREST);
			smimg = cv_image<unsigned char>(smallFrame);
			scaled = true;
		}

		//		cout << "scaled?" << scaled << " - roi: " << roiPT << "/" << roiSZ << endl;
		std::vector<dlib::rectangle> &dets = faceDetector(smimg, 0);
		std::cout << "Number of faces detected: " << dets.size() << endl;

		// did we detect any faces?
		if (dets.size() > 0)
		{
			// if so, then for each detected face
			for (size_t i = 0; i < dets.size(); i++)
			{
				// offset the detection position to the absolute position in the image
				// by adding the ROI x and y to each corner.
				dlib::rectangle &d = dets[i];
				d.set_left(d.left() + roiPT.x);
				d.set_top(d.top() + roiPT.y);
				d.set_right(d.right() + roiPT.x);
				d.set_bottom(d.bottom() + roiPT.y);

				// and if it's scaled, then also rescale it
				if (scaled)
				{
					d.set_left(d.left() * 2);
					d.set_top(d.top() * 2);
					d.set_right(d.right() * 2);
					d.set_bottom(d.bottom() * 2);
				}
			}
			shape = sp(gray_img, dets[0]);

			// hack to swap in new face with other face
			// if there is more than one face, then replace the face1 with the 2nd face detected...
			// TODO make this less random.... but this is just Proof-of-Concept.

			if (dets.size() > 1)
			{
				f1cvimg = frame.clone();
				f1shape = sp(gray_img, dets[1]);
			}

			// dets has had [clipStart.l, clipStart.t] subtracted
			//			std::cout << "number of parts: " << shape.num_parts() << endl;

			// f1cvimg == OpenCV format image from face1.{png,jpg}
			// f1shape == detection for face1 image, origin is [0, 0]
			// frame == current cam frame
			// shape == detection for current cam frame, orgin is [clipStart.l, clipStart.t]
			//	i.e. if shape.part(0) was said it was at point [0, 0], it is really @ [roiPT.x, roiPT.y]
			// roiPT == top left of the ROI, which maps the orgin for the shape object.
			// roiSZ == sixe of the ROI.

			prevDet0 = Rect(dets[0].left(),
				dets[0].top(),
				dets[0].right(),
				dets[0].bottom());

			warp(f1cvimg, f1shape, frame, shape, roiPT, scaled);
			scaled = false;
			hadDet = true;
		}
		else
		{
			hadDet = false;
		}

		if (win.is_closed())
		{
			break;
		}

		// Now view our face poses on the screen.
		win.clear_overlay();
		array2d<bgr_pixel> scr(screen_height, screen_width);

		resize_image(img, scr);
		win.set_image(scr);

		prevDet0 = Rect(Point(0, 0), frame.size());
	}

	return 0;
}

// ----------------------------------------------------------------------------------------
